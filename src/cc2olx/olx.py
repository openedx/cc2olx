import json
import logging
import xml.dom.minidom
from functools import cached_property
from typing import List, Type

from cc2olx.constants import FALLBACK_OLX_CONTENT
from cc2olx.content_post_processors import AbstractContentPostProcessor
from cc2olx.content_post_processors.dataclasses import ContentPostProcessorContext
from cc2olx.content_post_processors.utils import load_content_post_processor_types
from cc2olx.content_processors import AbstractContentProcessor
from cc2olx.content_processors.dataclasses import ContentProcessorContext
from cc2olx.content_processors.utils import load_content_processor_types
from cc2olx.iframe_link_parser import KalturaIframeLinkParser
from cc2olx.utils import passport_file_parser

logger = logging.getLogger()


class OlxExport:
    """
    This class is used to convert intermediate representation
    of Common Cartridge to OLX.

    OLX guide: https://docs.openedx.org/en/latest/educators/navigation/olx.html
    """

    def __init__(
        self,
        cartridge,
        link_file=None,
        passport_file=None,
        relative_links_source=None,
        content_types_with_custom_blocks=None,
    ):
        self.cartridge = cartridge
        self.doc = None
        self.link_file = link_file
        self.passport_file = passport_file
        self.relative_links_source = relative_links_source
        self.iframe_link_parser = KalturaIframeLinkParser(self.link_file) if link_file else None
        self.lti_consumer_present = False
        self.lti_consumer_ids = set()
        self._content_types_with_custom_blocks = content_types_with_custom_blocks or []
        self._content_processors = self._create_content_processors(load_content_processor_types())
        self._content_post_processors = self._create_content_post_processors(load_content_post_processor_types())

    def _create_content_processors(
        self,
        content_processor_types: List[Type[AbstractContentProcessor]],
    ) -> List[AbstractContentProcessor]:
        """
        Create content processor instances.
        """
        context = ContentProcessorContext(
            iframe_link_parser=self.iframe_link_parser,
            lti_consumer_ids=self.lti_consumer_ids,
            content_types_with_custom_blocks=self._content_types_with_custom_blocks,
        )
        return [content_processor_type(self.cartridge, context) for content_processor_type in content_processor_types]

    def _create_content_post_processors(
        self,
        content_post_processor_types: List[Type[AbstractContentPostProcessor]],
    ) -> List[AbstractContentPostProcessor]:
        """
        Create content post processor instances.
        """
        context = ContentPostProcessorContext(relative_links_source=self.relative_links_source)
        return [
            content_post_processor_type(self.cartridge, context)
            for content_post_processor_type in content_post_processor_types
        ]

    def xml(self):
        self.doc = xml.dom.minidom.Document()
        self.doc.appendChild(self.doc.createComment(" Generated by cc2olx "))

        xcourse = self.doc.createElement("course")
        xcourse.setAttribute("org", self.cartridge.get_course_org())
        xcourse.setAttribute("course", "Some_cc_Course")
        xcourse.setAttribute("name", self.cartridge.get_title())
        xcourse.setAttribute("url_name", "course")
        self.doc.appendChild(xcourse)

        tags = "chapter sequential vertical".split()
        self._add_olx_nodes(xcourse, self.cartridge.normalized["children"], tags)

        return self.doc.toprettyxml()

    def policy(self):
        """
        Returns minimal course policy file with disabled wiki tab in form of json string.

        See details about policy here:
        https://docs.openedx.org/en/latest/educators/olx/policies/course.html
        """

        policy = {
            "course/course": {
                "tabs": [
                    {"course_staff_only": True, "name": "Home", "type": "course_info"},
                    {
                        "course_staff_only": False,
                        "name": "Course",
                        "type": "courseware",
                    },
                    {
                        "course_staff_only": False,
                        "name": "Textbooks",
                        "type": "textbooks",
                    },
                    {
                        "course_staff_only": False,
                        "name": "Discussion",
                        "type": "discussion",
                    },
                    {
                        "course_staff_only": False,
                        "name": "Wiki",
                        "type": "wiki",
                        "is_hidden": True,
                    },
                    {
                        "course_staff_only": False,
                        "name": "Progress",
                        "type": "progress",
                    },
                ],
                "advanced_modules": [],
            }
        }

        lti_passports = self._get_lti_passport_list()

        if self.lti_consumer_ids:
            policy["course/course"]["advanced_modules"].append("lti_consumer")

        if len(lti_passports):
            policy["course/course"]["lti_passports"] = lti_passports

        for xblock_name in self._content_types_with_custom_blocks:
            policy["course/course"]["advanced_modules"].append(xblock_name)

        return json.dumps(policy)

    def _get_lti_passport_list(self):
        """
        Gets a list of lti passports.
        """
        passports = dict()
        lti_passports = []
        if self.passport_file:
            passports = passport_file_parser(self.passport_file)
            lti_passports = list(passports.values())

        for lti_id in self.lti_consumer_ids:
            if lti_id not in passports:
                logger.warning("Missing LTI Passport for %s. Using default.", lti_id)
                lti_passports.append("{}:consumer_key:consumer_secret".format(lti_id))
        return lti_passports

    def _add_olx_nodes(self, element, course_data, tags):
        """
        Recursively loops through the normalized common cartridge course data and
        adds appropriate OLX nodes to given course element.

        Expects `course_data` to be a list of triple nested elements that
        represent chapters in OLX courseware structure, like:
        ```
        [
            {
                'children': [        <----- chapter
                    'children': [        <----- sequential
                        'children': [        <----- vertical
                            ...content of vertical...
                        ]
                    ]
                ]
            }
        ]
        ```
        """

        leaf = not tags
        for element_data in course_data:
            if leaf:
                children = self._create_olx_nodes(element_data)
            else:
                children = [self.doc.createElement(tags[0])]

            for child in children:
                if "title" in element_data:
                    child.setAttribute("display_name", element_data["title"])
                    if element_data["identifierref"] and not child.getAttribute("url_name"):
                        child.setAttribute("url_name", element_data["identifierref"])
                    elif not child.getAttribute("url_name") and element_data.get("children"):
                        child.setAttribute("url_name", element_data["identifier"])

                element.appendChild(child)

                if "children" in element_data:
                    self._add_olx_nodes(child, element_data["children"], tags[1:])

    def _create_olx_nodes(self, element_data: dict) -> List["xml.dom.minidom.Element"]:
        """
        Help to create OLX nodes of different Common Cartridge resource types.

        If the OLX nodes can't be gotten from Common Cartridge resource,
        fallback nodes are returned. Otherwise, OLX nodes provided by the
        first content processor that can handle the resource is returned.

        Args:
            element_data (dict): a normalized CC element data.

        Returns:
            [List]: List of OLX nodes that needs to be written.
        """
        idref = element_data.get("identifierref")
        if not idref:
            return self._fallback_olx_nodes

        resource = self.cartridge.define_resource(idref)
        if resource is None:
            logger.warning("Missing resource: %s", idref)
            return self._fallback_olx_nodes

        for content_processor in self._content_processors:
            if olx_nodes := content_processor.process(resource, idref):
                for olx_node in olx_nodes:
                    self._post_process(olx_node)
                return olx_nodes

        logger.warning('The resource with "%s" identifier value is not supported.', idref)
        return self._fallback_olx_nodes

    @cached_property
    def _fallback_olx_nodes(self) -> List["xml.dom.minidom.Element"]:
        """
        Provide fallback OLX nodes.
        """
        txt = self.doc.createCDATASection(FALLBACK_OLX_CONTENT)
        html_node = self.doc.createElement("html")
        html_node.appendChild(txt)

        return [html_node]

    def _post_process(self, olx_node: "xml.dom.minidom.Element") -> None:
        """
        Perform additional processing of the generated OLX node.
        """
        for post_processor in self._content_post_processors:
            post_processor.process(olx_node)
